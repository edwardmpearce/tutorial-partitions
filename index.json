[
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "  In number theory and combinatorics, a partition of a positive integer $n$, also called an integer partition, is a way of writing $n$ as a sum of positive integers. - Wikipedia\n As addition is commutative, the order of the summands is arbitrary and may be rearranged so that they appear in decreasing order. For example, we may partition the integer $5$ in the following seven distinct ways:\n $5$ $4 + 1$ $3 + 2$ $3 + 1 + 1$ $2 + 2 + 1$ $2 + 1 + 1 + 1$ $1 + 1 + 1 + 1 + 1$  With this in mind, we begin with the following definitions:\nFirst Definitions A partition is a finite nonincreasing sequence of positive integers, often denoted by symbols such as $\\lambda$, $\\mu$, or $p$.\nIn other words, if $\\lambda$ is a partition, then it can be viewed as a function $\\lambda:\\mathbb{Z}_{\u0026gt;0}\\to\\mathbb{Z}_{\u0026gt;0}$ such that $\\lambda(i)\\ge\\lambda(j)$ for all $i\\le j$, and there is some $M\\in\\mathbb{Z}_{\u0026gt;0}$ such that $\\lambda(i)=0$ for all $i\\ge M$.\nWe may express the data stored in a partition by writing out the finite sequence as $\\lambda=(\\lambda_{1},\\lambda_{2},\\ldots,\\lambda_{k})$ with $\\lambda_{1}\\ge\\lambda_{2}\\ge\\ldots\\ge\\lambda_{k}\u0026gt;0$. These $\\lambda_{i}$ are called the parts of the partition $\\lambda$.\nWe define the size of a partition $\\lambda$ to be the sum of its parts. That is, $\\mathrm{size}(\\lambda):=\\sum_{i=1}^{\\infty}\\lambda(i)=\\sum_{i=1}^{k}\\lambda_{i}$. We say that $\\lambda$ is a partition of $n$, and write $\\lambda\\vdash n$, where $n=\\mathrm{size}(\\lambda)$.\nWe define the length of a partition $\\lambda$ to be the number of nonzero parts in $\\lambda$. That is, $\\mathrm{length}(\\lambda):=\\max\\{i\\in\\mathbb{Z}_{\u0026gt;0}|\\lambda(i)\\ne0\\}$. For $\\lambda=(\\lambda_{1},\\lambda_{2},\\ldots,\\lambda_{k})$ with $\\lambda_{1}\\ge\\lambda_{2}\\ge\\ldots\\ge\\lambda_{k}\u0026gt;0$, we have $\\mathrm{length}(\\lambda)=k$.\nExercise The SageMath mathematics software system has some functionality for working with partitions built in.\nWe can create a partition $p=(6,3,1)$ with the following command (case sensitive):\np = Partition([6,3,1])  We can calculate $\\mathrm{size}(p)=6+3+1=10$ and $\\mathrm{length}(p)=3$ using the size() and length() methods respectively. These actually just make use of the built in functions sum and len for Python lists.\np.size() # Equal to sum(p) p.length() # Equal to len(p)  We can access the parts of a partition in the same way we would for a Python list, either by indexing or slicing, or we can use the get_part() method. Note that in Python/SageMath indices are $0$-based (i.e. indices start from $0$ instead of $1$).\nmu = Partition([6,4,4,2,1]) mu.get_part(0), mu.get_part(1), mu.get_part(2), mu.get_part(3), mu.get_part(4), mu.get_part(5) # (6, 4, 4, 2, 1, 0) mu[1:4] # Slice from index 1 (inclusive) to index 4 (exclusive) # [4, 4, 2]  You can practice executing SageMath and Python code in the SageMathCell below.\np = Partition([6,3,1]) # You can edit this code yourself print(\"My partition p = {0} has size(p) = {1} and length(p) = {2}\".format( p, p.size(), p.length())) mu = Partition([6,4,4,2,1]) print(mu.get_part(0), mu.get_part(3), mu.get_part(4), mu.get_part(5)) print(p.size() == sum(p))   "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction In this chapter we cover the basic definitions and notations regarding integer partitions.\n"
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/visualization/conventions/",
	"title": "Diagram conventions",
	"tags": [],
	"description": "",
	"content": " Notice that the way we indexed cells on the previous page is the same way as we index entries in matrices, first by rows and then by columns. This way of doing things is called English notation and is the most commonly used in the literature.\nLet $\\lambda = (6,3,1)$. We highlight the cells $s = (1,3), t = (2,3) \\in \\mathrm{Young}(\\lambda)$ in English notation below:\nWe will introduce three other ways to draw Young diagrams: French notation, Russian notation, and Cartesian notation, and draw the Young diagram of $\\lambda = (6,3,1)$ with the cells $s = (1,3), t = (2,3) \\in \\mathrm{Young}(\\lambda)$ highlighted below using each of these conventions in turn.\nFrench notation French notation relates to English notation by a reflection in the $x$-axis, i.e. stack parts in rows with index increasing from bottom to top, i.e. longest row/largest part at the bottom, aligned to the bottom-left corner of the 1st quadrant.\nRussian notation Russian notation may be obtained by rotating a diagram drawn using English notation anticlockwise 135 degrees.\nDiagrams in Russian notation will be used to motivate Maya diagrams later.\nCartesian notation Sometimes we will use a convention obtained by rotating a diagram drawn using English notation anticlockwise 90 degrees, which we will call \u0026lsquo;Cartesian\u0026rsquo; notation. In Cartesian notation the diagrams are aligned to the bottom-left corner of the 1st quadrant, and parts correspond to columns which decrease in size from left to right. The $(i,j)$ coordinates for cells resemble the standard Cartesian coordinates $(x,y)$ for the Euclidean plane.\nWe will revisit Cartesian notation when we discuss applications to monomial ideals in algebraic geometry.\nSummary In the table below we summarize the relations between the different conventions for drawing Young diagrams and indexing cells in terms of the change of basis matrix to the standard Euclidean basis:\n   Convention Transformation matrix     Cartesian $\\left(\\begin{array}{cc}1 \u0026amp; 0\\\\0 \u0026amp; 1\\end{array}\\right)$   English $\\left(\\begin{array}{cc}0 \u0026amp; 1\\\\-1 \u0026amp; 0\\end{array}\\right)$   French $\\left(\\begin{array}{cc}0 \u0026amp; 1\\\\1 \u0026amp; 0\\end{array}\\right)$   Russian $\\left(\\begin{array}{cc}1 \u0026amp; -1\\\\1 \u0026amp; 1\\end{array}\\right)$    Display options in SageMath We can choose how we want Ferrers and Young diagrams/tableaux to be displayed in SageMath using Partitions.options() to set global options. The keyword convention (or its alias notation) can be set to either 'French' or 'English' (not case sensitive), and we can also use the diagram_str keyword to choose the character used for cells when printing Ferrers diagrams. By default, Ferrers diagrams are printed using the English convention with asterisks \u0026quot;*\u0026quot; for cells.\nmu = Partition([5,5,3,2,1]) mu.pp() # ***** # ***** # *** # ** # * Partitions.options(convention='French', diagram_str=\u0026quot;\u0026amp;\u0026quot;) mu.pp() # \u0026amp; # \u0026amp;\u0026amp; # \u0026amp;\u0026amp;\u0026amp; # \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; # \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; Partitions.options._reset()  You can practice executing SageMath and Python code in the SageMathCell below.\nmu = Partition([5,5,3,2,1]) # You can edit this code yourself mu.pp() Partitions.options(convention='French', diagram_str=\"\u0026\") mu.pp() Partitions.options._reset()   "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/visualization/",
	"title": "Visualization",
	"tags": [],
	"description": "",
	"content": " Graphical representations Now that we\u0026rsquo;ve given a few basic definitions, it\u0026rsquo;s time to appreciate the fact that we can think about partitions visually and thus utilize our natural spatial intuition to further understand them, rather than only thinking of them as sequences of numbers.\nThe two most commonly used methods of representing partitions with diagrams are Ferrers diagrams and Young diagrams. We will discuss other diagrammatic representations later.\nFerrers diagrams To represent a partition as a Ferrers diagram we draw a row of dots for each part in the partition and stack them from top to bottom in descending order, i.e. longest row/largest part at the top, aligned to the upper-left corner (of the 4th quadrant). For example, the Ferrers diagram for the partition $\\lambda = (6,3,1)$ is given by\nWe can use the ferrers_diagram() method to return the Ferrers diagram of a partition as a string, and we can use the pp() method to print the Ferrers diagram to the display.\nmu = Partition([6,3,1]) print(type(mu.ferrers_diagram())) # \u0026lt;type 'str'\u0026gt; mu.pp() # Runs print(mu.ferrers_diagram()), returns None # ****** # *** # *  Young diagrams and Young tableaux A Young diagram is very similar to a Ferrers diagram except we draw rows of boxes instead of dots. For example, we display the Young diagram for the partition $\\lambda = (6,3,1)$ below.\nYoung diagrams are a more useful way of visualizing partitions because we can fill the boxes (cells) with numbers (or other data) to obtain Young tableux.\nConjugation The conjugate of the partition $\\lambda$ is the partition $\\lambda\u0026rsquo;$ obtained by swapping the rows and columns in the Young diagram. Formally, $\\lambda\u0026rsquo;(j):=|\\{i:\\lambda(i)\\ge j\\}|$ for each $j\\in \\mathbb{Z}_{\u0026gt;0}$. This is also called the associated partition or the transpose in the literature.\nFor example, if $\\lambda = (6,3,1)$, then its conjugate is given by $\\lambda\u0026rsquo;=(3, 2, 2, 1, 1, 1)$.\n Notice that conjugation is a size-preserving operation on the set of partitions. That is, $\\mathrm{size}(\\lambda\u0026rsquo;)=\\mathrm{size}(\\lambda)$. Notice that if we take the conjugate of a partition twice we get back the partition we started with. That is, $(\\lambda^\\prime)^\\prime=\\lambda$. Therefore conjugation is what is known as an involution, i.e. a self-inverse function, on the set of partitions.  We can calculate the conjugate of a partition in SageMath using the conjugate() method or the helper function of the same name.\nPartition([5,5,3,2,1]).conjugate() # Same as conjugate(Partition([5,5,3,2,1])) # [5, 4, 3, 2, 2] Partition([5,5,3,2,1]).conjugate().conjugate() # Same as conjugate(Partition([5, 4, 3, 2, 2])) # [5, 5, 3, 2, 1]  Cells We call each box (resp. dot) in a Young (resp. Ferrers) diagram a cell in the diagram, with coordinates $(i,j)$ for the cell in the $i$-th row and $j$-th column of a partition. For a partition $\\lambda=(\\lambda_{1},\\lambda_{2},\\ldots,\\lambda_{k})$ we identify its Young diagram with the set of cells $$\\mathrm{Young}(\\lambda) = \\{(i,j)|1 \\le i \\le k, 1 \\le j \\le \\lambda_{i}\\}$$\nLet $\\lambda = (6,3,1)$. We highlight the cells $s = (1,3), t = (2,3) \\in \\mathrm{Young}(\\lambda)$ in the diagram below\nWe can obtain the coordinates of the cells in a partition as a list using the cells() method, but note that in Python/SageMath that indices are $0$-based (i.e. indices start from $0$ instead of $1$).\nPartition([6,3,1]).cells() # [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), (1, 2), (2, 0)]  It should be clear that the size of a partition $\\lambda$ is equal to the number of cells in its Young diagram, that is $\\mathrm{size}(\\lambda) = |\\mathrm{Young}(\\lambda)|$, and that we can recover the parts of a partition from its Young diagram by counting the number of cells in the corresponding row: $\\lambda_{i} = |\\{(i,j)\\in\\mathrm{Young}(\\lambda)\\}| = \\max\\{j:(i,j)\\in\\mathrm{Young}(\\lambda)\\}$.\nGiven a partition $\\lambda$, there is a canonical bijection between the cells in $\\mathrm{Young}(\\lambda)$ and those in $\\mathrm{Young}(\\lambda\u0026rsquo;)$ arising from the relation $(i,j)\\in\\mathrm{Young}(\\lambda)\\iff(j,i)\\in\\mathrm{Young}(\\lambda\u0026rsquo;)$.\nArms, legs, and hooks Given a cell $(i,j)$ in a Young diagram, we define the arm, leg, and hook of $(i,j)\\in\\mathrm{Young}(\\lambda)$ as the following subsets of $\\mathrm{Young}(\\lambda)$:\n$$ \\mathrm{arm}_{\\lambda}(i,j):= \\{(i,y):j \u0026lt; y \\le \\lambda_i\\}\\subset\\mathrm{Young}(\\lambda)$$ $$ \\mathrm{leg}_{\\lambda}(i,j):= \\{(x,j):i \u0026lt; x \\le \\lambda\u0026rsquo;_j\\}\\subset\\mathrm{Young}(\\lambda)$$ $$ \\mathrm{hook}_{\\lambda}(i,j):= \\{(x,y):i \u0026lt; x \\le \\lambda\u0026rsquo;_j, j \\le y \\le \\lambda_{i}\\} = \\mathrm{arm}_{\\lambda}(i,j)\\cup\\mathrm{leg}_{\\lambda}(i,j)\\cup\\{(i,j)\\}$$\nThe arm of a cell $s=(i,j)$ consists of the cells on the same row of the Young diagram as $s$ which are further from the origin. Similarly, the leg of $s\\in\\mathrm{Young}(\\lambda)$ consists of all cells in $\\mathrm{Young}(\\lambda)$ which lie on the same column, but further from the origin. Finally, $\\mathrm{hook}_{\\lambda}(s)$ is made up of all the cells from both the arm and leg of $s$ in $\\lambda$ together with the cell $s$ itself.\nAs an example, we let $\\lambda = (6,3,1)$ and $s = (1,3)\\in \\mathrm{Young}(\\lambda)$ and highlight cells in $\\mathrm{arm}_{\\lambda}(s)$ with the letter $a$ on a red background and cells in $\\mathrm{leg}_{\\lambda}(s)$ with the letter $l$ on a green background in the diagram below:\nGiven a partition $\\lambda$, we can define associated functions $a_{\\lambda},l_{\\lambda},h_{\\lambda}:\\mathrm{Young}(\\lambda)\\to\\mathbb{Z}_{\\ge0}$, called the arm length, leg length, and hook length, respectively, which act on cells in the Young diagram of $\\lambda$ as follows:\n$$ a_{\\lambda}(i,j):=\\lambda_i - j $$ $$ l_{\\lambda}(i,j):=\\lambda\u0026rsquo;_j - i $$ $$ h_{\\lambda}(i,j):= a_{\\lambda}(i,j) + l_{\\lambda}(i,j) + 1 $$\nwhere $\\lambda\u0026rsquo;$ is the conjugate partition to $\\lambda$.\nFor $\\lambda = (6,3,1)$, $s = (1,3)\\in \\mathrm{Young}(\\lambda)$ as above, we find that $a_{\\lambda}(s) = 6 - 3 = 3$, $l_{\\lambda}(s) = 2 - 1 = 1$, $h_{\\lambda}(s) = 3 + 1 + 1 = 5$.\nAs their names suggest, the functions $a_{\\lambda},l_{\\lambda},h_{\\lambda}$ count the number of cells in the arm, leg, and hook of a cell, respectively, that is $a_{\\lambda}(i,j)=|\\mathrm{arm}_{\\lambda}(i,j)|$, $l_{\\lambda}(i,j)=|\\mathrm{leg}_{\\lambda}(i,j)|$, and $h_{\\lambda}(i,j)=|\\mathrm{hook}_{\\lambda}(i,j)|$. In principle the functions $a_{\\lambda},l_{\\lambda},h_{\\lambda}$ could be extended to the lattice $(\\mathbb{Z}_{\\ge0})^{2}\\to\\mathbb{Z}$ using the fact that $\\lambda(i)=0$ for $i\u0026gt;\\mathrm{length}(\\lambda)$.\nTable of functions In the table below we recap the definitions from this subsection along with their implementations as methods for the Partition class in SageMath, as well as introducing a few other functions in passing. At this point we only remark that the functions for $\\alpha$-upper hook length and $\\alpha$-lower hook length are simply generalisations of the classical hook length discussed above and coincide when $\\alpha=1$.\n   Math notation SageMath method Description     $\\mathrm{arm}_{\\lambda}(i,j)$ arm_cells(i,j) $\\{(i,y):j \u0026lt; y \\le \\lambda_i\\}$   $\\mathrm{leg}_{\\lambda}(i,j)$ leg_cells(i,j) $\\{(x,j):i \u0026lt; x \\le \\lambda\u0026rsquo;_j\\}$   $\\mathrm{hook}_{\\lambda}(i,j)$ hook_cells(i,j) $\\mathrm{arm}_{\\lambda}(i,j)\\cup\\mathrm{leg}_{\\lambda}(i,j)\\cup\\{(i,j)\\}$   $a_{\\lambda}(i,j)$ arm_length(i,j) $\\lambda_i - j = |\\mathrm{arm}_{\\lambda}(i,j)|$   $l_{\\lambda}(i,j)$ leg_length(i,j) $\\lambda\u0026rsquo;_j - i = |\\mathrm{leg}_{\\lambda}(i,j)|$   $h_{\\lambda}(i,j)$ hook_length(i,j) $a_{\\lambda}(i,j) + l_{\\lambda}(i,j) + 1 = |\\mathrm{hook}_{\\lambda}(i,j)|$   $\\mathrm{Graph}(a_{\\lambda})$ arm_lengths() A Young tableau of $\\lambda$ with cells filled in with their arm lengths   $\\mathrm{Graph}(l_{\\lambda})$ leg_lengths() A Young tableau of $\\lambda$ with cells filled in with their leg lengths   $\\mathrm{Graph}(h_{\\lambda})$ hook_lengths() A Young tableau of $\\lambda$ with cells filled in with their hook lengths   $h^{\\ast}_{\\lambda}(i,j;\\alpha)$ upper_hook(i,j,alpha) $\\lambda^{\\prime}_j - i + \\alpha(\\lambda_i - j + 1) = l_{\\lambda}(i,j) + \\alpha(a_{\\lambda}(i,j) + 1)$   $h_{\\ast}^{\\lambda}(i,j;\\alpha)$ lower_hook(i,j,alpha) $\\lambda^{\\prime}_j - i + 1 + \\alpha(\\lambda_i - j) = l_{\\lambda}(i,j) + 1 + \\alpha\\cdot a_{\\lambda}(i,j)$   $\\mathrm{Graph}(h^{\\ast}_{\\lambda}(\\cdot;\\alpha))$ upper_hook_lengths() Tableau of $\\lambda$ with cells filled in with their $\\alpha$-upper hook lengths   $\\mathrm{Graph}(h_{\\ast}^{\\lambda}(\\cdot;\\alpha))$ lower_hook_lengths() Tableau of $\\lambda$ with cells filled in with their $\\alpha$-lower hook lengths    mu = Partition([6,3,1]) mu.arm_cells(0,2) # Indices are zero-based # [(0, 3), (0, 4), (0, 5)] mu.leg_length(0,2) # Check above example # 1 mu.hook_lengths() # Returns a list of lists # [[8, 6, 5, 3, 2, 1], [4, 2, 1], [1]]  You can practice executing SageMath and Python code in the SageMathCell below.\nmu = Partition([6,3,1]) # You can edit this code yourself print(type(mu.ferrers_diagram())) mu.pp() print(Partition([5,5,3,2,1]).conjugate()) print(conjugate(Partition([5,5,3,2,1]))) print(type(Partition([5,5,3,2,1]).conjugate())) print(type(conjugate(Partition([5,5,3,2,1]))))   "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/notation/",
	"title": "Notation",
	"tags": [],
	"description": "",
	"content": " Alternative notation Besides thinking of partitions as a sequence of summands (parts), we may encode the data in a handful of other ways. This can be useful for computation, compactness, or for realizing the appearance of partitions in other areas of mathematics and beyond.\nIn fact, the cycle of discovery often begins with mathematicians studying an object of interest in their own field, only later realizing that after a little bit of manipulation the problem at hand can also be viewed in terms of partitions.\nExponential notation The most simple alternative to describing a partition $\\lambda$ by listing its parts $\\lambda_{j}$ is exponential notation, where instead we count the number of parts of size $i$ appearing in $\\lambda$ for each positive integer $i$, that is $\\alpha_{i}=|\\{j\\in\\mathbb{Z}_{\u0026gt;0}|\\lambda(j)=i\\}|$, to form a finite sequence of nonnegative integers $\\exp(\\lambda):\\mathbb{Z}_{\u0026gt;0}\\to\\mathbb{Z}_{\\ge0}$ given by $\\exp(\\lambda)(i):=\\alpha_{i}$.\nWe usually write this as $\\lambda=1^{\\alpha_{1}}2^{\\alpha_{2}}3^{\\alpha_{3}}\\ldots\\lambda_{1}^{\\alpha_{\\lambda_{1}}}$ where $\\lambda_{1}=\\max\\{i\\in\\mathbb{Z}_{\u0026gt;0}|\\alpha_{\\lambda}(i)\\ne0\\}$ is called the largest part in $\\lambda$, but may also directly write $\\exp(\\lambda)=(\\alpha_{1},\\alpha_{2},\\alpha_{3},\\ldots,\\alpha_{\\lambda_{1}})$. For example:\nWe can obtain the exponential notation for a given partition in SageMath using the to_exp() method, and we can construct a partition from its exponential form using the exp keyword argument in the constructor.\nPartition([6,4,4,2,1]).to_exp() # [1, 1, 0, 2, 0, 1] Partition(exp=[1,1,0,2,0,1]) # [6, 4, 4, 2, 1]  Frobenius Coordinates The Frobenius rank of a partition $\\lambda$ is given by the number of cells on the main diagonal of $\\lambda$, and formally defined to be $\\max\\{i\\in\\mathbb{Z}_{\u0026gt;0}:\\lambda_{i}\\ge i\\}$. This is also equal to the length of the largest square fitting into the Young diagram of $\\lambda$. For example, the Frobenius rank of the partition $\\lambda = (6,4,4,2,1)$ is $3$.\nWe can obtain the Frobenius rank for a given partition in SageMath using the frobenius_rank() method.\nThe Frobenius coordinates of a partition $\\lambda$ of Frobenius rank $r$ is a pair of length-$r$ integer-valued vectors $p,q$ given by listing the arm and leg statistics, respectively, of the cells along the main diagonal in $\\lambda$. That is, for $i=1,2,\\ldots,r$\n$$p_{i}=a_{\\lambda}(i,i),q_{i}=l_{\\lambda}(i,i).$$\nFor example, the diagram below illustrates how to obtain the Frobenius coordinates $p=(5,2,1)$, $q=(4,2,0)$ from the partition $\\lambda = (6,4,4,2,1)$:\nWe can obtain the Frobenius coordinates for a given partition in SageMath using the frobenius_coordinates() method, and we can also construct a partition using the frobenius_coordinates keyword argument in the constructor.\nPartition([6,4,4,2,1]).frobenius_coordinates() # ([5, 2, 1], [4, 2, 0]) Partition(frobenius_coordinates=([5, 2, 1], [4, 2, 0])) # [6,4,4,2,1]  Notice that if a partition $\\lambda$ has Frobenius rank $r$, then for $i=1,2,\\ldots,r-1$, its Frobenius coordinates $p,q$ must satisfy $p_{i+1}\\le p_{i}-1$, and $q_{i+1}\\le q_{i}-1$. That is to say, the Frobenius coordinates consist of strictly decreasing integer sequences of finite length.\n  Proof   Let $\\lambda$ be a partition, so $\\lambda_{i} - \\lambda_{i+1} \\ge 0$. Therefore\n$$ p_{i+1} - p_{i} = a_{\\lambda}(i,i) - a_{\\lambda}(i+1,i+1) = \\lambda_{i}-i - (\\lambda_{i+1}-(i+1)) = \\lambda_{i} - \\lambda_{i+1} + 1 \\ge 1.$$\nThus $p_{i+1} - p_{i} \\ge 1$ and $p_{i+1}\\le p_{i}-1$ as required. The proof is analogous for $q$ noting that the conjugate $\\lambda\u0026rsquo;$ is also a partition.\n  If the Frobenius coordinates of a partition $\\lambda$ is given by the pair $(p,q)\\in\\mathbb{Z}_{\\ge0}^{r}\\times\\mathbb{Z}_{\\ge0}^{r}$, then the Frobenius coordinates of its conjugate $\\lambda\u0026rsquo;$ are given by the pair $(q,p)$. This follows from the deduction that $a_{\\lambda\u0026rsquo;}(i,j)=l_{\\lambda}(j,i)$, which we apply to the special case $i=j$, along with the bijection $\\mathrm{Young}(\\lambda)\\to\\mathrm{Young}(\\lambda\u0026rsquo;)$ given by $(i,j)\\mapsto(j,i)$ mentioned earlier.\nMaya diagrams, zero-one sequences, and Dyck words In this section we introduce Maya diagrams, and explain their connection to partitions, Dyck paths from combinatorics, and the physical model known as \u0026ldquo;Dirac\u0026rsquo;s electron sea\u0026rdquo;.\nMaya diagrams are used to visualize binary sequences of zeros and ones, and the two states 0 and 1 can be used to represent a wide range of paired notions, such as two directions when traversing a binary tree, two vectors in a basis of a 2D lattice, or a pair of oppositely charged particles (e.g. electrons and positrons).\nMinimal zero-one sequences We begin by explaining the zero_one_sequence() method for partitions in SageMath. We draw the Young diagram of a partition in English notation and label edges on its outer rim/boundary path according to the rule North=0 and East=1, and then read this 0-1 sequence from $(0, -\\infty)$ to $(+\\infty, 0)$ so that part size increases as we read along the boundary path.\nThough such a sequence starts with infinitely many 0s and end with infinitely many 1s, the zero_one_sequence() method omits these to return a finite output, describing only the edges on the boundary of the Young diagram which do not lie on the axes. This may be called the minimal 0-1 sequence of a partition.\nBelow we illustrate how to obtain the minimal zero-one sequence $(1,0,1,1,0,1,1,1,0)$ from the partition $\\lambda=(6,3,1)$:\nWe can obtain the minimal zero-one sequence of a given partition in SageMath using the zero_one_sequence() method, and we can also construct a partition using the zero_one keyword argument in the constructor.\nPartition([6,3,1]).zero_one_sequence() # [1, 0, 1, 1, 0, 1, 1, 1, 0] Partition(zero_one=[1,0,1,1,0,1,1,1,0]) # Same as Partitions().from_zero_one([1,0,1,1,0,1,1,1,0]) # [6,3,1]  This leads to reading boundary paths from right to left in Russian and Cartesian notations.\nDyck words Next we explain the to_dyck_word() method for partitions in SageMath. We draw the Young diagram of a partition in English notation and label edges on its outer rim/boundary path according to the rule North=1 and East=0, and then read this 0-1 sequence from $(0, -\\infty)$ to $(+\\infty, 0)$ so that part size increases as we read along the boundary path.\nWe will begin with an illustration of how to obtain the Maya diagram corresponding to a given partition before discussing the formal definitions and details. Just as with Young diagrams, Maya diagrams are also subject to choices of convention for how they relate to a particular partition, but for our purposes, we will fix the following convention:\nWe can obtain the Dyck word associated to a given partition in SageMath using the to_dyck_word() method, and we can also recover the partition from its Dyck word using the to_partition() method.\nPartition([6,3,1]).to_dyck_word() # Partition([6,3,1]).to_dyck_word(10) # Partition([6,3,1]).to_dyck_word().to_partition() # [6,3,1]  States Consider the set of integers $\\mathbb{Z}$ as the disjoint union $\\mathbb{Z}=\\mathbb{\\mathbb{Z}}_{\u0026lt;0}\\sqcup\\mathbb{Z}_{\\ge0}$ of the negative integers $\\mathbb{Z}_{\u0026lt;0}$ and the nonnegative integers $\\mathbb{Z}_{\\ge0}$. We define a state to be a subset $S\\subset\\mathbb{Z}$ such that the symmetric difference $S\\Delta\\mathbb{Z}_{\\ge0}$ is finite. That is, for $S^{C}:=\\mathbb{Z}\\setminus S=\\{n\\in\\mathbb{Z}|n\\notin S\\}$\n$$ S\\Delta\\mathbb{Z}_{\\ge0}=(S\\setminus\\mathbb{Z}_{\\ge0})\\sqcup(\\mathbb{Z}_{\\ge0}\\setminus S)=(S\\cap\\mathbb{Z}_{\u0026lt;0})\\sqcup(S^{C}\\cap\\mathbb{Z}_{\\ge0})\\,\\text{finite.} $$\nWe may identify a state $S\\subset\\mathbb{Z}$ with the pair of (necessarily) finite sets $(S\\cap\\mathbb{Z}_{\u0026lt;0})$ and $(S^{C}\\cap\\mathbb{Z}_{\\ge0})$ by the bijection between\n$$ \\{S\\subset\\mathbb{Z}|S\\Delta\\mathbb{Z}_{\\ge0}\\,\\text{finite}\\} \\leftrightarrow \\{(A,B)|A\\subset\\mathbb{Z}_{\\ge0}\\,\\text{finite},B\\subset\\mathbb{Z}_{\u0026lt;0}\\,\\text{finite}\\} $$\ngiven by $S\\mapsto(S^{C}\\cap\\mathbb{Z}_{\\ge0}$, $S\\cap\\mathbb{Z}_{\u0026lt;0})$, with inverse given by $(A,B)\\mapsto A^{C}\\cap(B\\cup\\mathbb{Z}_{\\ge0})$.\n  Proof   For $S\\subset\\mathbb{Z}$ such that $S\\Delta\\mathbb{Z}_{\\ge0}$ is finite, let $(A,B):=(S^{C}\\cap\\mathbb{Z}_{\\ge0},S\\cap\\mathbb{Z}_{\u0026lt;0})$, then $A\\subset\\mathbb{Z}_{\\ge0}$, $B\\subset\\mathbb{Z}_{\u0026lt;0}$, and $S\\Delta\\mathbb{Z}_{\\ge0}=A\\sqcup B$, so $A$, $B$ must both be finite. Moreover,\n$$ A^{C}\\cap(B\\cup\\mathbb{Z}_{\\ge0}) = (S^{C}\\cap\\mathbb{Z}_{\\ge0})^{C}\\cap((S\\cap\\mathbb{Z}_{\u0026lt;0})\\cup\\mathbb{Z}_{\\ge0}) $$ $$ = (S\\cup\\mathbb{Z}_{\u0026lt;0})\\cap((S\\cup\\mathbb{Z}_{\\ge0})\\cap(\\mathbb{\\mathbb{Z}}_{\u0026lt;0}\\cup\\mathbb{Z}_{\\ge0})) $$ $$ = (S\\cup\\emptyset)\\cap\\mathbb{Z}=S $$\nby De Morgan\u0026rsquo;s laws and associativity and distributativity properties of union and intersection.\nOn the other hand, for finite subsets $A\\subset\\mathbb{Z}_{\\ge0}$, $B\\subset\\mathbb{Z}_{\u0026lt;0}$, let $S=A^{C}\\cap(B\\cup\\mathbb{Z}_{\\ge0})$, then $S^{C}=A\\cup(B^{C}\\cap\\mathbb{Z}_{\u0026lt;0})$, and so\n$$ S^{C}\\cap\\mathbb{Z}_{\\ge0} = (A\\cup(B^{C}\\cap\\mathbb{Z}_{\u0026lt;0}))\\cap\\mathbb{Z}_{\\ge0} $$ $$ = (A\\cap\\mathbb{Z}_{\\ge0})\\cup((B^{C}\\cap\\mathbb{Z}_{\u0026lt;0})\\cap\\mathbb{Z}_{\\ge0}) $$ $$ = A\\cup\\emptyset=A $$\nas $A\\subset\\mathbb{Z}_{\\ge0}$, and also\n$$ S\\cap\\mathbb{Z}_{\u0026lt;0} = (A^{C}\\cap(B\\cup\\mathbb{Z}_{\\ge0}))\\cap\\mathbb{Z}_{\u0026lt;0} $$ $$ = (A\\cap\\mathbb{Z}_{\u0026lt;0}\\cap B)\\cup(A\\cap\\mathbb{Z}_{\u0026lt;0}\\cap\\mathbb{Z}_{\\ge0}) $$ $$ = A\\cap\\mathbb{Z}_{\u0026lt;0}\\cap B=B $$\nas $B\\subset\\mathbb{Z}_{\u0026lt;0}=(\\mathbb{Z}_{\\ge0})^{C}\\subset A^{C}$, as $A\\subset\\mathbb{Z}_{\\ge0}$. Therefore $S\\Delta\\mathbb{Z}_{\\ge0}=(S^{C}\\cap\\mathbb{Z}_{\\ge0})\\sqcup(S\\cap\\mathbb{Z}_{\u0026lt;0})=A\\sqcup B$ is finite.\n  Zero-one sequences A Maya diagram is a function $\\mathrm{\\boldsymbol{m}}:\\mathbb{Z}\\to\\{0,1\\}$ such that there exist $N,M\\in\\mathbb{Z}$ such that for all $\\nu\u0026gt;N$ we have $\\boldsymbol{\\mathrm{m}}(\\nu)=1$ and for all $\\nu\u0026lt;M$ we have $\\boldsymbol{\\mathrm{m}}(\\nu)=0$. It follows that $M\\le N+1$.\nLet $S\\subset\\mathbb{Z}$ be a state, then its identity function $\\mathbb{1}_{S}:\\mathbb{Z}\\to\\{0,1\\}$,\n$$\\mathbb{1}_{S}(\\nu) = \\begin{cases} 1 \u0026amp; \\nu\\in S\\\\ 0 \u0026amp; \\nu\\notin S \\end{cases}$$\nis a Maya diagram, where we may take $N=\\max(S^{C}\\cap\\mathbb{Z}_{\\ge0})$, $M=\\min(S\\cap\\mathbb{Z}_{\u0026lt;0})\\in\\mathbb{Z}$.\nOn the other hand, for a Maya diagram $\\mathrm{\\boldsymbol{m}}:\\mathbb{Z}\\to\\{0,1\\}$ we may define a state $S=\\boldsymbol{\\mathrm{m}}^{-1}(1)=\\{\\nu\\in\\mathbb{Z}|\\boldsymbol{\\mathrm{m}}(\\nu)=1\\}$, in which case\n$$ |S\\cap\\mathbb{Z}_{\u0026lt;0}|=|\\{\\nu\\in\\mathbb{Z}_{\u0026lt;0}|\\mathrm{\\boldsymbol{m}}(\\nu)=1\\}|\\le\\max(0,-M) $$\nand\n$$ |S^{C}\\cap\\mathbb{Z}_{\\ge0}|=|\\{\\nu\\in\\mathbb{Z}_{\\ge0}|\\boldsymbol{\\mathrm{m}}(\\nu)=0\\}|\\le\\max(0,N+1).$$\n  Proof   Let $\\mathrm{\\boldsymbol{m}}:\\mathbb{Z}\\to\\{0,1\\}$ be a Maya diagram such that $\\boldsymbol{\\mathrm{m}}(\\nu)=1$ for all $\\nu\u0026gt;N$, and $\\boldsymbol{\\mathrm{m}}(\\nu)=0$ for all $\\nu\u0026lt;M$. Let $S=\\boldsymbol{\\mathrm{m}}^{-1}(1)=\\{\\nu\\in\\mathbb{Z}|\\boldsymbol{\\mathrm{m}}(\\nu)=1\\}$. Then\n$$ S\\cap\\mathbb{Z}_{\u0026lt;0} = \\{\\nu\\in\\mathbb{Z}_{\u0026lt;0}|\\mathrm{\\boldsymbol{m}}(\\nu)=1\\} \\subset \\{\\nu\\in\\mathbb{Z}|M\\le\\nu\u0026lt;0\\} $$\nand\n$$ S^{C}\\cap\\mathbb{Z}_{\\ge0} = \\{\\nu\\in\\mathbb{Z}_{\\ge0}|\\boldsymbol{\\mathrm{m}}(\\nu)=0\\} \\subset \\{\\nu\\in\\mathbb{Z}|0\\le\\nu\\le N\\}. $$\n  We define the charge of a Maya diagram/state to be the difference\n$$ \\mathrm{charge}(S)=|S^{C}\\cap\\mathbb{Z}_{\\ge0}|-|S\\cap\\mathbb{Z}_{\u0026lt;0}|=|\\boldsymbol{\\mathrm{m}}^{-1}(0)\\cap\\mathbb{Z}_{\\ge0}|-|\\boldsymbol{\\mathrm{m}}^{-1}(1)\\cap\\mathbb{Z}_{\u0026lt;0}|.$$\nBeta numbers Beta numbers have applications in Representation theory.\nInterchanging between notations We can prove that these notations are equivalent and that we can freely interchange between them, i.e. that the set of partitions is in bijection with the set of e.g. Frobenius coordinates\nWe also demonstrate and explain how these have been implemented in SageMath\n# Insert code here  "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/intro/statistics/",
	"title": "Statistics",
	"tags": [],
	"description": "",
	"content": " Partition Statistics Now that we have discussed many different ways of thinking about partitions, we move on to discussing properties (or statistics) of partitions, and how to calculate them.\nCalculating from different notations We can prove that these notations are equivalent and that we can freely interchange between them, i.e. that the set of partitions is in bijection with the set of e.g. Frobenius coordinates\nWe also demonstrate and explain how these have been implemented in SageMath\n# Insert code here  "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/",
	"title": "Integer Partitions Tutorial",
	"tags": [],
	"description": "",
	"content": " Integer Partitions Tutorial Partitions are studied in the mathematical fields of number theory and combinatorics, but have applications in many other areas, such as algebraic geometry, theoretical physics, and representation theory, where partitions arise in the study of monomial ideals, symmetric polynomials, special eigenfunctors and operators, and irreducible representations of symmetric groups to name a few.\nThis tutorial gives a subjective view on the theory of integer partitions, along with sample code for calculations using SageMath.\nIt is intended to be useful both for those interested in learning more about the combinatorics of partitions (along with some applications), as well as those wanting to learn how to use SageMath for combinatorial calculations.\nYou can navigate this website using the arrow keys.\nSageMath SageMath is a free open-source mathematics software system using a Python-based language which you can download and install for yourself, or simply run online or in the cloud. We will demonstrate some functionality of SageMath\u0026rsquo;s module for integer partitions (tutorial, documentation, source), but hopefully improve on the documentation already available by providing an accessible, illustrated, and interactive explanation of the mathematical background at the same time.\nIf you want to learn more about the multitude of other uses of SageMath for mathematical computations, check out their extensive documentation.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and make a pull request.\nHi! My name is Edward and I am the author of this tutorial. If you want to find out more about me or get in touch, you can check out my personal website. If you like what you are reading please consider donating (link in menu) so I can continue creating educational content.\n "
},
{
	"uri": "https://edwardmpearce.github.io/tutorial-partitions/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]